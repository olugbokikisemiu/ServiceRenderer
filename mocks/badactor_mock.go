// Code generated by MockGen. DO NOT EDIT.
// Source: common/badactor/types.go

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	gomock "github.com/golang/mock/gomock"
	badactor "github.com/sleekservices/ServiceRenderer/common/badactor"
	reflect "reflect"
	time "time"
)

// MockBadactorService is a mock of BadactorService interface
type MockBadactorService struct {
	ctrl     *gomock.Controller
	recorder *MockBadactorServiceMockRecorder
}

// MockBadactorServiceMockRecorder is the mock recorder for MockBadactorService
type MockBadactorServiceMockRecorder struct {
	mock *MockBadactorService
}

// NewMockBadactorService creates a new mock instance
func NewMockBadactorService(ctrl *gomock.Controller) *MockBadactorService {
	mock := &MockBadactorService{ctrl: ctrl}
	mock.recorder = &MockBadactorServiceMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockBadactorService) EXPECT() *MockBadactorServiceMockRecorder {
	return m.recorder
}

// CreateInfraction mocks base method
func (m *MockBadactorService) CreateInfraction(ctx context.Context, infraction *badactor.Infraction) (*badactor.Infraction, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateInfraction", ctx, infraction)
	ret0, _ := ret[0].(*badactor.Infraction)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CreateInfraction indicates an expected call of CreateInfraction
func (mr *MockBadactorServiceMockRecorder) CreateInfraction(ctx, infraction interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateInfraction", reflect.TypeOf((*MockBadactorService)(nil).CreateInfraction), ctx, infraction)
}

// CountInfraction mocks base method
func (m *MockBadactorService) CountInfraction(ctx context.Context, actorName, ruleName string, expireTime time.Time) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CountInfraction", ctx, actorName, ruleName, expireTime)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CountInfraction indicates an expected call of CountInfraction
func (mr *MockBadactorServiceMockRecorder) CountInfraction(ctx, actorName, ruleName, expireTime interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CountInfraction", reflect.TypeOf((*MockBadactorService)(nil).CountInfraction), ctx, actorName, ruleName, expireTime)
}

// CreateJail mocks base method
func (m *MockBadactorService) CreateJail(ctx context.Context, jail *badactor.Jail) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateJail", ctx, jail)
	ret0, _ := ret[0].(error)
	return ret0
}

// CreateJail indicates an expected call of CreateJail
func (mr *MockBadactorServiceMockRecorder) CreateJail(ctx, jail interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateJail", reflect.TypeOf((*MockBadactorService)(nil).CreateJail), ctx, jail)
}

// FindJail mocks base method
func (m *MockBadactorService) FindJail(ctx context.Context, actorName, ruleName string, releaseTime time.Time) (*badactor.Jail, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FindJail", ctx, actorName, ruleName, releaseTime)
	ret0, _ := ret[0].(*badactor.Jail)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FindJail indicates an expected call of FindJail
func (mr *MockBadactorServiceMockRecorder) FindJail(ctx, actorName, ruleName, releaseTime interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindJail", reflect.TypeOf((*MockBadactorService)(nil).FindJail), ctx, actorName, ruleName, releaseTime)
}

// UpdateJail mocks base method
func (m *MockBadactorService) UpdateJail(ctx context.Context, jail *badactor.Jail) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateJail", ctx, jail)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateJail indicates an expected call of UpdateJail
func (mr *MockBadactorServiceMockRecorder) UpdateJail(ctx, jail interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateJail", reflect.TypeOf((*MockBadactorService)(nil).UpdateJail), ctx, jail)
}

// MockBadStudio is a mock of BadStudio interface
type MockBadStudio struct {
	ctrl     *gomock.Controller
	recorder *MockBadStudioMockRecorder
}

// MockBadStudioMockRecorder is the mock recorder for MockBadStudio
type MockBadStudioMockRecorder struct {
	mock *MockBadStudio
}

// NewMockBadStudio creates a new mock instance
func NewMockBadStudio(ctrl *gomock.Controller) *MockBadStudio {
	mock := &MockBadStudio{ctrl: ctrl}
	mock.recorder = &MockBadStudioMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockBadStudio) EXPECT() *MockBadStudioMockRecorder {
	return m.recorder
}

// IsJailedFor mocks base method
func (m *MockBadStudio) IsJailedFor(c context.Context, actorName, ruleName string) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsJailedFor", c, actorName, ruleName)
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsJailedFor indicates an expected call of IsJailedFor
func (mr *MockBadStudioMockRecorder) IsJailedFor(c, actorName, ruleName interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsJailedFor", reflect.TypeOf((*MockBadStudio)(nil).IsJailedFor), c, actorName, ruleName)
}

// Infraction mocks base method
func (m *MockBadStudio) Infraction(c context.Context, actorName, ruleName string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Infraction", c, actorName, ruleName)
	ret0, _ := ret[0].(error)
	return ret0
}

// Infraction indicates an expected call of Infraction
func (mr *MockBadStudioMockRecorder) Infraction(c, actorName, ruleName interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Infraction", reflect.TypeOf((*MockBadStudio)(nil).Infraction), c, actorName, ruleName)
}

// Pardon mocks base method
func (m *MockBadStudio) Pardon(c context.Context, actorName, ruleName string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Pardon", c, actorName, ruleName)
	ret0, _ := ret[0].(error)
	return ret0
}

// Pardon indicates an expected call of Pardon
func (mr *MockBadStudioMockRecorder) Pardon(c, actorName, ruleName interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Pardon", reflect.TypeOf((*MockBadStudio)(nil).Pardon), c, actorName, ruleName)
}
